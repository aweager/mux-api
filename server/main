#!/bin/zsh

#### Usage:
#       ./main [-L | --listen <socket>] [--log-level <level>] [--log-file <file>]

zmodload zsh/net/socket
zmodload zsh/param/private
zmodload zsh/zutil

private -a arg_socket arg_log_level arg_log_file
zparseopts -D -E -F -- \
    {L,-listen}:=arg_socket \
    -log-level:=arg_log_level \
    -log-file:=arg_log_file \
        || return 1

private socket
if [[ -n $arg_socket ]]; then
    socket="$arg_socket[-1]"
else
    socket="$(mktemp -u)"
fi

typeset -gx LOG_LEVEL
if [[ -n $arg_log_level ]]; then
    LOG_LEVEL="$arg_log_level[-1]"
else
    LOG_LEVEL="info"
fi

if [[ -n $arg_log_file ]]; then
    typeset -g LOG="$arg_log_file[-1]"
fi

source "${0:a:h}/logger.zsh"

private -a pids
private -a files
trap '
    trap - INT TERM EXIT
    log.info "Shutting down: $1"

    coproc.kill

    if [[ -S "$socket" ]]; then
        log.info "Deleting socket: $socket"
        rm "$socket"
    fi

    log.info "Goodbye"
    kill $$
' INT TERM EXIT

log "
-- Starting instance $$ --
"

log.info "Setting up coprocess"
local coproc_pid
function coproc.build() {
    coproc "./executor.zsh"
    coproc_pid=$!
}

function coproc.write() {
    echo "$@" >&p
}

function coproc.wait() {
    read -p
}

function coproc.interrupt() {
    # TODO any way to not restart whole coprocess, maintaining state?
    kill -HUP $coproc_pid
    coproc.build
}

function coproc.kill() {
    if [[ -n $coproc_pid ]]; then
        log.info "Terminating coprocess"
        kill -HUP $coproc_pid
        coproc_pid=""
    fi
}

coproc.build

zsocket -l "$socket" || exit 1
private socket_fd="$REPLY"
log.info "Listening on $socket"

while true; do
    () {
        log.info "Waiting for a client"
        zsocket -a "$1"
        private recv_fd="$REPLY"

        read -u $recv_fd
        coproc.write "$REPLY"
        read -u $recv_fd
        coproc.write "$REPLY"

        log.trace "Waiting for client to respond"
        private client_response
        read -u $recv_fd client_response

        log.trace "Client responded with '$client_response'"

        if [[ "$client_response" == "interrupted" ]]; then
            log.info "Interrupting current job"
            coproc.interrupt
        elif [[ "$client_response" == "backgrounded" ]]; then
            log.info "Client backgrounded, waiting for coproc"
            coproc.wait
        fi

        exec {recv_fd}>&-
        recv_fd=""
        send=""

        log.info "Client disconnected"
    } "$socket_fd"
done
